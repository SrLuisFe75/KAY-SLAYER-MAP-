import React, { useState, useEffect, useRef } from 'react';
import { 
  Map, 
  MapPin, 
  Radar, 
  Filter,
  Target,
  Eye,
  Zap,
  Moon,
  Skull,
  Beaker,
  Shield,
  Navigation,
  Crosshair,
  Activity,
  AlertTriangle,
  Search,
  Settings,
  Layers,
  Radio,
  Car,
  Clock,
  TrendingUp
} from 'lucide-react';

const QuantumTacticalMap = () => {
  const [userLocation, setUserLocation] = useState({ lat: 40.7128, lng: -74.0060 });
  const [mapZoom, setMapZoom] = useState(14);
  const [detectedBots, setDetectedBots] = useState([]);
  const [isScanning, setIsScanning] = useState(false);
  const [selectedBot, setSelectedBot] = useState(null);
  
  // Filtros del mapa
  const [filters, setFilters] = useState({
    maxDistance: 5, // km
    platforms: {
      uber: true,
      instacart: true,
      doordash: true,
      amazonFlex: true
    },
    botTypes: {
      speed_bot: true,
      pattern_bot: true,
      location_spoof: true,
      multi_app: true
    },
    threatLevels: {
      low: true,
      medium: true,
      high: true,
      critical: true
    },
    showPoisoned: true,
    showSleeping: true,
    showDestroyed: false
  });

  const [mapLayers, setMapLayers] = useState({
    heatmap: true,
    clusters: true,
    movementPaths: false,
    dangerZones: true,
    myLocation: true
  });

  // Simular bots detectados en tiempo real
  useEffect(() => {
    if (isScanning) {
      const scanInterval = setInterval(() => {
        // Simular nuevos bots detectados
        if (Math.random() < 0.4) {
          const newBot = generateRandomBot();
          setDetectedBots(prev => {
            const filtered = prev.filter(bot => 
              Date.now() - bot.lastSeen.getTime() < 300000 // Mantener bots por 5 minutos
            );
            return [newBot, ...filtered].slice(0, 50); // Max 50 bots
          });
        }

        // Actualizar posiciones de bots existentes
        setDetectedBots(prev => prev.map(bot => {
          if (bot.status === 'active' && Math.random() < 0.3) {
            const newLat = bot.location.lat + (Math.random() - 0.5) * 0.003;
            const newLng = bot.location.lng + (Math.random() - 0.5) * 0.003;
            
            return {
              ...bot,
              location: { lat: newLat, lng: newLng },
              lastSeen: new Date(),
              movementHistory: [...(bot.movementHistory || []), bot.location].slice(-10)
            };
          }
          return bot;
        }));
      }, 3000);

      return () => clearInterval(scanInterval);
    }
  }, [isScanning, userLocation]);

  const generateRandomBot = () => {
    const platforms = ['uber', 'instacart', 'doordash', 'amazonFlex'];
    const botTypes = ['speed_bot', 'pattern_bot', 'location_spoof', 'multi_app'];
    const statuses = ['active', 'poisoned', 'sleeping', 'destroyed'];
    const threatLevels = ['low', 'medium', 'high', 'critical'];

    const bot = {
      id: `bot_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
      platform: platforms[Math.floor(Math.random() * platforms.length)],
      botType: botTypes[Math.floor(Math.random() * botTypes.length)],
      status: statuses[Math.floor(Math.random() * statuses.length)],
      threatLevel: threatLevels[Math.floor(Math.random() * threatLevels.length)],
      location: {
        lat: userLocation.lat + (Math.random() - 0.5) * 0.02,
        lng: userLocation.lng + (Math.random() - 0.5) * 0.02
      },
      confidence: Math.random() * 0.4 + 0.6, // 60-100%
      responseTime: Math.random() * 80 + 10, // 10-90ms
      earnings: Math.random() * 400 + 50, // $50-450/day
      lastSeen: new Date(),
      health: Math.random() * 100,
      firstDetected: new Date(),
      movementHistory: []
    };

    bot.distance = calculateDistance(userLocation, bot.location);
    return bot;
  };

  const calculateDistance = (pos1, pos2) => {
    const R = 6371; // Radio de la Tierra en km
    const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const dLng = (pos2.lng - pos1.lng) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  };

  // Filtrar bots según criterios
  const filteredBots = detectedBots.filter(bot => {
    if (bot.distance > filters.maxDistance) return false;
    if (!filters.platforms[bot.platform]) return false;
    if (!filters.botTypes[bot.botType]) return false;
    if (!filters.threatLevels[bot.threatLevel]) return false;
    if (bot.status === 'poisoned' && !filters.showPoisoned) return false;
    if (bot.status === 'sleeping' && !filters.showSleeping) return false;
    if (bot.status === 'destroyed' && !filters.showDestroyed) return false;
    return true;
  });

  const getBotColor = (bot) => {
    if (bot.status === 'destroyed') return 'bg-gray-500';
    if (bot.status === 'sleeping') return 'bg-blue-500';
    if (bot.status === 'poisoned') return 'bg-green-500';
    
    switch (bot.threatLevel) {
      case 'critical': return 'bg-red-600';
      case 'high': return 'bg-orange-500';
      case 'medium': return 'bg-yellow-500';
      default: return 'bg-blue-400';
    }
  };

  const getBotIcon = (bot) => {
    switch (bot.status) {
      case 'destroyed': return Skull;
      case 'sleeping': return Moon;
      case 'poisoned': return Beaker;
      default: return Target;
    }
  };

  const getPlatformColor = (platform) => {
    const colors = {
      uber: 'text-black',
      instacart: 'text-green-500',
      doordash: 'text-red-500',
      amazonFlex: 'text-orange-500'
    };
    return colors[platform] || 'text-gray-400';
  };

  const toggleFilter = (category, key) => {
    setFilters(prev => ({
      ...prev,
      [category]: typeof prev[category] === 'object' 
        ? { ...prev[category], [key]: !prev[category][key] }
        : !prev[category]
    }));
  };

  const startScanning = () => {
    setIsScanning(true);
    setDetectedBots([]);
  };

  const stopScanning = () => {
    setIsScanning(false);
  };

  const centerOnBot = (bot) => {
    setUserLocation(bot.location);
    setSelectedBot(bot);
  };

  const zoomIn = () => setMapZoom(prev => Math.min(20, prev + 1));
  const zoomOut = () => setMapZoom(prev => Math.max(10, prev - 1));

  // Estadísticas del mapa
  const stats = {
    totalDetected: filteredBots.length,
    activeThreats: filteredBots.filter(b => b.status === 'active').length,
    neutralized: filteredBots.filter(b => ['destroyed', 'sleeping', 'poisoned'].includes(b.status)).length,
    averageDistance: filteredBots.length > 0 
      ? (filteredBots.reduce((sum, bot) => sum + bot.distance, 0) / filteredBots.length).toFixed(1)
      : 0
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 text-white">
      {/* Header del mapa táctico */}
      <div className="bg-black/50 backdrop-blur-sm border-b border-blue-500/30 p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Map className={`${isScanning ? 'text-green-400 animate-pulse' : 'text-blue-400'}`} size={28} />
            <div>
              <h1 className="text-xl font-bold text-blue-300">Mapa Táctico Cuántico</h1>
              <p className="text-sm text-gray-300">Visualización en tiempo real de bots detectados</p>
            </div>
          </div>
          
          <div className="flex items-center gap-4">
            <button
              onClick={isScanning ? stopScanning : startScanning}
              className={`flex items-center gap-2 px-4 py-2 rounded font-semibold transition-colors ${
                isScanning 
                  ? 'bg-red-600 hover:bg-red-700' 
                  : 'bg-green-600 hover:bg-green-700'
              }`}
            >
              <Radar className={isScanning ? 'animate-spin' : ''} size={16} />
              {isScanning ? 'Detener Escaneo' : 'Iniciar Escaneo'}
            </button>
          </div>
        </div>
      </div>

      <div className="flex h-screen">
        {/* Panel de filtros */}
        <div className="w-80 bg-black/30 backdrop-blur-sm border-r border-gray-500/30 p-4 overflow-y-auto">
          <h2 className="text-lg font-bold text-white mb-4 flex items-center gap-2">
            <Filter />
            Filtros y Capas
          </h2>

          {/* Estadísticas rápidas */}
          <div className="grid grid-cols-2 gap-2 mb-6">
            <div className="bg-blue-900/30 rounded p-3 text-center">
              <div className="text-lg font-bold text-blue-400">{stats.totalDetected}</div>
              <div className="text-xs text-gray-300">Detectados</div>
            </div>
            <div className="bg-red-900/30 rounded p-3 text-center">
              <div className="text-lg font-bold text-red-400">{stats.activeThreats}</div>
              <div className="text-xs text-gray-300">Amenazas</div>
            </div>
            <div className="bg-green-900/30 rounded p-3 text-center">
              <div className="text-lg font-bold text-green-400">{stats.neutralized}</div>
              <div className="text-xs text-gray-300">Neutralizados</div>
            </div>
            <div className="bg-purple-900/30 rounded p-3 text-center">
              <div className="text-lg font-bold text-purple-400">{stats.averageDistance}</div>
              <div className="text-xs text-gray-300">Km promedio</div>
            </div>
          </div>

          {/* Filtro de distancia */}
          <div className="mb-6">
            <label className="block text-sm font-semibold mb-2">Radio de Escaneo</label>
            <input
              type="range"
              min="1"
              max="20"
              value={filters.maxDistance}
              onChange={(e) => setFilters(prev => ({ ...prev, maxDistance: parseInt(e.target.value) }))}
              className="w-full"
            />
            <div className="text-sm text-gray-300">{filters.maxDistance} km</div>
          </div>

          {/* Filtros de plataforma */}
          <div className="mb-6">
            <h3 className="font-semibold mb-2">Plataformas</h3>
            {Object.entries(filters.platforms).map(([platform, enabled]) => (
              <label key={platform} className="flex items-center gap-2 mb-1">
                <input
                  type="checkbox"
                  checked={enabled}
                  onChange={() => toggleFilter('platforms', platform)}
                  className="rounded"
                />
                <span className={`capitalize ${getPlatformColor(platform)}`}>
                  {platform}
                </span>
              </label>
            ))}
          </div>

          {/* Filtros de tipo de bot */}
          <div className="mb-6">
            <h3 className="font-semibold mb-2">Tipos de Bot</h3>
            {Object.entries(filters.botTypes).map(([type, enabled]) => (
              <label key={type} className="flex items-center gap-2 mb-1">
                <input
                  type="checkbox"
                  checked={enabled}
                  onChange={() => toggleFilter('botTypes', type)}
                  className="rounded"
                />
                <span className="capitalize text-gray-300">
                  {type.replace('_', ' ')}
                </span>
              </label>
            ))}
          </div>

          {/* Filtros de nivel de amenaza */}
          <div className="mb-6">
            <h3 className="font-semibold mb-2">Nivel de Amenaza</h3>
            {Object.entries(filters.threatLevels).map(([level, enabled]) => (
              <label key={level} className="flex items-center gap-2 mb-1">
                <input
                  type="checkbox"
                  checked={enabled}
                  onChange={() => toggleFilter('threatLevels', level)}
                  className="rounded"
                />
                <span className={`capitalize ${
                  level === 'critical' ? 'text-red-400' :
                  level === 'high' ? 'text-orange-400' :
                  level === 'medium' ? 'text-yellow-400' : 'text-blue-400'
                }`}>
                  {level}
                </span>
              </label>
            ))}
          </div>

          {/* Estados especiales */}
          <div className="mb-6">
            <h3 className="font-semibold mb-2">Estados</h3>
            <label className="flex items-center gap-2 mb-1">
              <input
                type="checkbox"
                checked={filters.showPoisoned}
                onChange={() => toggleFilter('showPoisoned')}
                className="rounded"
              />
              <span className="text-green-400">Envenenados</span>
            </label>
            <label className="flex items-center gap-2 mb-1">
              <input
                type="checkbox"
                checked={filters.showSleeping}
                onChange={() => toggleFilter('showSleeping')}
                className="rounded"
              />
              <span className="text-blue-400">Durmiendo</span>
            </label>
            <label className="flex items-center gap-2 mb-1">
              <input
                type="checkbox"
                checked={filters.showDestroyed}
                onChange={() => toggleFilter('showDestroyed')}
                className="rounded"
              />
              <span className="text-gray-400">Destruidos</span>
            </label>
          </div>

          {/* Capas del mapa */}
          <div>
            <h3 className="font-semibold mb-2">Capas</h3>
            {Object.entries(mapLayers).map(([layer, enabled]) => (
              <label key={layer} className="flex items-center gap-2 mb-1">
                <input
                  type="checkbox"
                  checked={enabled}
                  onChange={() => setMapLayers(prev => ({ ...prev, [layer]: !prev[layer] }))}
                  className="rounded"
                />
                <span className="capitalize text-gray-300">
                  {layer.replace(/([A-Z])/g, ' $1').toLowerCase()}
                </span>
              </label>
            ))}
          </div>
        </div>

        {/* Área principal del mapa */}
        <div className="flex-1 relative">
          {/* Controles del mapa */}
          <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
            <button
              onClick={zoomIn}
              className="bg-black/50 backdrop-blur-sm border border-gray-500/30 p-2 rounded hover:bg-gray-700"
            >
              +
            </button>
            <button
              onClick={zoomOut}
              className="bg-black/50 backdrop-blur-sm border border-gray-500/30 p-2 rounded hover:bg-gray-700"
            >
              -
            </button>
          </div>

          {/* Mapa simulado */}
          <div className="h-full bg-gradient-to-br from-gray-800 to-gray-900 relative overflow-hidden">
            {/* Grid del mapa */}
            <div className="absolute inset-0 opacity-10">
              {Array.from({length: 20}).map((_, i) => (
                <div key={i} className="absolute border-gray-500" style={{
                  left: `${i * 5}%`,
                  top: 0,
                  bottom: 0,
                  borderLeft: '1px solid currentColor'
                }} />
              ))}
              {Array.from({length: 20}).map((_, i) => (
                <div key={i} className="absolute border-gray-500" style={{
                  top: `${i * 5}%`,
                  left: 0,
                  right: 0,
                  borderTop: '1px solid currentColor'
                }} />
              ))}
            </div>

            {/* Tu ubicación */}
            {mapLayers.myLocation && (
              <div 
                className="absolute transform -translate-x-1/2 -translate-y-1/2 z-20"
                style={{
                  left: '50%',
                  top: '50%'
                }}
              >
                <div className="relative">
                  <div className="w-4 h-4 bg-blue-500 rounded-full border-2 border-white animate-pulse" />
                  <div className="absolute inset-0 w-4 h-4 bg-blue-500 rounded-full animate-ping" />
                </div>
                <Car className="text-blue-400 mt-1" size={16} />
              </div>
            )}

            {/* Radio de escaneo */}
            <div 
              className="absolute border-2 border-blue-500/30 rounded-full transform -translate-x-1/2 -translate-y-1/2"
              style={{
                left: '50%',
                top: '50%',
                width: `${(filters.maxDistance / 20) * 800}px`,
                height: `${(filters.maxDistance / 20) * 800}px`
              }}
            />

            {/* Bots detectados */}
            {filteredBots.map(bot => {
              const x = 50 + ((bot.location.lng - userLocation.lng) * 10000) % 80;
              const y = 50 + ((bot.location.lat - userLocation.lat) * 10000) % 80;
              const IconComponent = getBotIcon(bot);
              
              return (
                <div
                  key={bot.id}
                  className="absolute transform -translate-x-1/2 -translate-y-1/2 cursor-pointer z-10"
                  style={{ left: `${x}%`, top: `${y}%` }}
                  onClick={() => centerOnBot(bot)}
                >
                  <div className={`w-3 h-3 rounded-full ${getBotColor(bot)} ${
                    selectedBot?.id === bot.id ? 'ring-2 ring-white animate-pulse' : ''
                  }`} />
                  <IconComponent size={12} className="text-white mt-1" />
                  
                  {/* Tooltip al hover */}
                  <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-black/80 text-white text-xs rounded px-2 py-1 opacity-0 hover:opacity-100 transition-opacity whitespace-nowrap">
                    {bot.platform} - {bot.distance.toFixed(1)}km
                  </div>
                </div>
              );
            })}

            {/* Paths de movimiento */}
            {mapLayers.movementPaths && filteredBots.forEach(bot => {
              if (bot.movementHistory && bot.movementHistory.length > 1) {
                // Aquí se dibujarían las líneas de movimiento
                // Simplificado para este ejemplo
              }
            })}
          </div>

          {/* Panel de información del bot seleccionado */}
          {selectedBot && (
            <div className="absolute bottom-4 left-4 bg-black/80 backdrop-blur-sm rounded-lg p-4 border border-gray-500/30 max-w-sm">
              <div className="flex items-center justify-between mb-2">
                <h3 className="font-bold text-white">Bot Seleccionado</h3>
                <button 
                  onClick={() => setSelectedBot(null)}
                  className="text-gray-400 hover:text-white"
                >
                  ×
                </button>
              </div>
              
              <div className="space-y-2 text-sm">
                <div>ID: <span className="text-blue-400">{selectedBot.id.slice(-8)}</span></div>
                <div>Plataforma: <span className={getPlatformColor(selectedBot.platform)}>{selectedBot.platform}</span></div>
                <div>Tipo: <span className="text-gray-300">{selectedBot.botType.replace('_', ' ')}</span></div>
                <div>Distancia: <span className="text-yellow-400">{selectedBot.distance.toFixed(2)} km</span></div>
                <div>Confianza: <span className="text-green-400">{(selectedBot.confidence * 100).toFixed(0)}%</span></div>
                <div>Estado: <span className={`${
                  selectedBot.status === 'active' ? 'text-red-400' :
                  selectedBot.status === 'poisoned' ? 'text-green-400' :
                  selectedBot.status === 'sleeping' ? 'text-blue-400' : 'text-gray-400'
                }`}>{selectedBot.status}</span></div>
                <div>Respuesta: <span className="text-orange-400">{selectedBot.responseTime.toFixed(0)}ms</span></div>
                <div>Ganancias: <span className="text-purple-400">${selectedBot.earnings.toFixed(0)}/día</span></div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default QuantumTacticalMap;
